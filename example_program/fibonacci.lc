/*
    Lambda Calculus Basic Concepts
    Author: Daan Phlips
*/

I := (λx.x);                            // The identity function, does nothing
EMPTY := (λx.);                         // The empty function, removes the subsequent term

SUCC := λn.λf.λx.f (n f x);             // The successor function
0 := λf.λx.x;                           // Encoding of the natural number zero

1 := SUCC 0;
2 := SUCC 1;
3 := SUCC 2;
4 := SUCC 3;
5 := SUCC 4;
6 := SUCC 5;
7 := SUCC 6;
8 := SUCC 7;

PLUS    := λm.λn.λf.λx.m f (n f x);     // Addition
MULT    := λm.λn.λf.m (n f);            // Multiplication

T       := λx.λy.x;                     // Encoding of the boolean True
F       := λx.λy.y;                     // Encoding of the boolean False

NOT     := (λp.p F T);                  // NOT function
AND     := λb1.λb2.b1 b2 b1;            // AND function
OR      := λb1.λb2.b1 b1 b2;            // OR  function
XOR     := λb1.λb2.b1 (NOT b2) b2;      // XOR function

PAIR    := λx.λy.λf.f x y;              // Creates a pairing of two elements
FIRST   := λp.p T;                      // Retrieves the first element
SECOND  := λp.p F;                      // Retrieves the second element

FIBSTEP := λp.(PAIR (PLUS (FIRST p) (SECOND p)) (FIRST p));
FIB := λn.FIRST (n FIBSTEP (PAIR 0 1));

println FIB 1;
println FIB 2;
println FIB 3;
println FIB 4;
println FIB 5;
println FIB 6;
println FIB 7;
println FIB 8;